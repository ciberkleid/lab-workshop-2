# Lift & Shift the Color Application to Kubernetes - Step 2

Now that you have built and published the application images, you can attempt to deploy them to Kubernetes.
Each image will be deployed using a Kubernetes `deployment` resource. The deployment creates one or more pods, each with a running instance of the image (aka a container) of the corresponding application.
Each app will also need a Kubernetes `service` resource, which will load balance requests across all instances of a particular pod.
The deployment and service resources will be defined declaratively using manifests (yaml files).

## Create deployment manifests

Create the manifest for the `deployment` of each application.
For now, you will start with a single color instance (`blue`).
Use the `kubectl` CLI with the option `--dry-run=client` to generate the yaml without applying it to Kubernetes. 
```execute-1
mkdir -p k8s/lift-and-shift

kubectl create deployment blue \
            --image $REGISTRY_HOST/color-app/blueorgreenservice \
            -o yaml --dry-run=client > k8s/lift-and-shift/blue-deployment.yaml

kubectl create deployment frontend \
            --image $REGISTRY_HOST/color-app/blueorgreenfrontend \
            -o yaml --dry-run=client > k8s/lift-and-shift/frontend-deployment.yaml

kubectl create deployment gateway \
            --image $REGISTRY_HOST/color-app/blueorgreengateway \
            -o yaml --dry-run=client > k8s/lift-and-shift/gateway-deployment.yaml

kubectl create deployment authgateway \
            --image $REGISTRY_HOST/color-app/authgateway \
            -o yaml --dry-run=client > k8s/lift-and-shift/authgateway-deployment.yaml
```

List all of the files you just created.
```execute-1
ls -l k8s/lift-and-shift/
```

Take a look at the blue deployment manifest as an example of the files you just created.
```editor:select-matching-text
file: ~/color-app/k8s/lift-and-shift/blue-deployment.yaml
text: "kind: Deployment" 
```

When running the apps locally, you had to ensure that each app ran on a separate port.
One benefit of running containers in Kubernetes is that you no longer need to manage port conflicts. 
This means all apps can start on the same port, which makes for simpler configuration.

Edit the deployment manifests to set the Spring Boot `server.port` property to 8080 using an environment variable.
This will override the `server.port` value set in the `application.properties` files.

You can use `yq`, a command-line tool for transforming yaml, to add an environment variable to each deployment manifest.
```execute-1
for i in k8s/lift-and-shift/*-deployment.yaml; do \
    yq eval \
        '.spec.template.spec.containers[0].env[0].key = "SERVER_PORT"' \
        -i $i; \
    yq eval \
        '.spec.template.spec.containers[0].env[0].value = "8080"' \
        -i $i; \
done
```

Return to the blue deployment manifest to verify that the environment variable has been added.
```editor:select-matching-text
file: ~/color-app/k8s/lift-and-shift/blue-deployment.yaml
text: "env:" 
```

## Create service manifests

Use the same "dry-run" approach as above to create the service manifests without applying them to Kubernetes.
In this step, you take advantage of the fact that all containers will be listening on port 8080 to make the service manifest configuration simpler as well.
Make sure to use the `spring.application.name` for the Kubernetes Service name so that Spring Cloud Kubernetes can locate the proper Service.
Notice that you are only including the blue instance for now uner the `blueandgreen` Service.
You will include the remaining colors at a later step.
```execute-1
kubectl create service clusterip blueorgreen \
            --tcp 80:8080 \
            -o yaml --dry-run=client > k8s/lift-and-shift/blue-service.yaml

kubectl create service clusterip blueorgreenfrontend \
            --tcp 80:8080 \
            -o yaml --dry-run=client > k8s/lift-and-shift/frontend-service.yaml

kubectl create service clusterip blueorgreengateway \
            --tcp 80:8080 \
            -o yaml --dry-run=client > k8s/lift-and-shift/gateway-service.yaml

kubectl create service clusterip blueorgreenauthgateway \
            --tcp 80:8080 \
            -o yaml --dry-run=client > k8s/lift-and-shift/authgateway-service.yaml
```

List all of the files you just created.
```execute-1
ls -l k8s/lift-and-shift/ | grep service
```

Take a look at the blueorgreen service manifest as an example of the files you just created.
```editor:select-matching-text
file: ~/color-app/k8s/lift-and-shift/blueorgreen-service.yaml
text: "kind: Service" 
```

## Create configmap manifests

From the [docs](https://docs.spring.io/spring-cloud-kubernetes/docs/current/reference/html/#configmap-propertysource):
```
Kubernetes provides a resource named ConfigMap to externalize the parameters to pass to your application in the form of key-value pairs or embedded application.properties or application.yaml files. The Spring Cloud Kubernetes Config project makes Kubernetes ConfigMap instances available during application bootstrapping and triggers hot reloading of beans or Spring context when changes are detected on observed ConfigMap instances.
```

Create a ConfigMap from the files in the `config-files` directory.
```execute-1
kubectl create configmap colorapp \
            --from-file=~/color-app/config-files/
            -o yaml --dry-run=client > k8s/lift-and-shift/colorapp-configmap.yaml
```

## Add environment variables to deployments

To make sure the apps can read configuration from the ConfigMap, you'll need to set the `spring.cloud.kubernetes.config.name` property, which specifies the name of the ConfigMap (the default value would otherwise be `spring.application.name`, which does not match the ConfigMap name in this case).
```
for i in k8s/lift-and-shift/*-deployment.yaml; do \
    yq eval \
        '.spec.template.spec.containers[0].env[0].key = "SPRING_CLOUD_KUBERNETES_CONFIG_NAME"' \
        -i $i; \
    yq eval \
        '.spec.template.spec.containers[0].env[0].value = "colorapp"' \
        -i $i; \
done
```

Since we simplified the Service definitions above by assuming all apps would start on port 8080, you need to make sure this is indeed true.
You can do so by setting the SERVER_PORT environment variable in each Deployment manifest:
```
for i in k8s/lift-and-shift/*-deployment.yaml; do \
    yq eval \
        '.spec.template.spec.containers[0].env[1].key = "SERVER_PORT"' \
        -i $i; \
    yq eval \
        '.spec.template.spec.containers[0].env[1].value = "8080"' \
        -i $i; \
done
```

The profile `kubernetes` will be automatically activated, but you need to also set the `blue` profile for the color backen service.
```
yq eval \
    '.spec.template.spec.containers[0].env[2].key = "SPRING_PROFILES_ACTIVE"' \
    -i k8s/lift-and-shift/blue-deployment.yaml
yq eval \
    '.spec.template.spec.containers[0].env[2].value = "blue"' \
    -i k8s/lift-and-shift/blue-deployment.yaml
```