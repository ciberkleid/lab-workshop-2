# Lift & Shift the Color Application to Kubernetes - Step 2

Now that you have built and published the application images, you can attempt to deploy them to Kubernetes.
Each image will be deployed using a Kubernetes `deployment` resource. The deployment creates one or more pods, each with a running instance of the image (aka a container) of the corresponding application.
Each app will also need a Kubernetes `service` resource, which will load balance requests across all instances of a particular pod.
The deployment and service resources will be defined declaratively using manifests (yaml files).

## Create deployment manifests

Create the manifest for the `deployment` of each application.
Note that the blueorgreenservice image needs to be deployed four times - blue, green, slowgreen, and yellow.
Use the `kubectl` CLI with the option `--dry-run=client` to generate the yaml without applying it to Kubernetes. 
```execute-1
mkdir k8s/lift-and-shift

kubectl create deployment configserver \
            --image $REGISTRY_HOST/color-app/configserver \
            -o yaml --dry-run=client > k8s/lift-and-shift/configserver-deployment.yaml

kubectl create deployment eurekaserver \
            --image $REGISTRY_HOST/color-app/eurekaserver \
            -o yaml --dry-run=client > k8s/lift-and-shift/eurekaserver-deployment.yaml

kubectl create deployment blue \
            --image $REGISTRY_HOST/color-app/blueorgreenservice \
            -o yaml --dry-run=client > k8s/lift-and-shift/blue-deployment.yaml

kubectl create deployment green \
            --image $REGISTRY_HOST/color-app/blueorgreenservice \
            -o yaml --dry-run=client > k8s/lift-and-shift/green-deployment.yaml

kubectl create deployment slowgreen \
            --image $REGISTRY_HOST/color-app/blueorgreenservice \
            -o yaml --dry-run=client > k8s/lift-and-shift/slowgreen-deployment.yaml

kubectl create deployment yellow \
            --image $REGISTRY_HOST/color-app/blueorgreenservice \
            -o yaml --dry-run=client > k8s/lift-and-shift/yellow-deployment.yaml

kubectl create deployment frontend \
            --image $REGISTRY_HOST/color-app/blueorgreenfrontend \
            -o yaml --dry-run=client > k8s/lift-and-shift/frontend-deployment.yaml

kubectl create deployment gateway \
            --image $REGISTRY_HOST/color-app/blueorgreengateway \
            -o yaml --dry-run=client > k8s/lift-and-shift/gateway-deployment.yaml

kubectl create deployment authgateway \
            --image $REGISTRY_HOST/color-app/authgateway \
            -o yaml --dry-run=client > k8s/lift-and-shift/authgateway-deployment.yaml
```

List all of the files you just created.
```execute-1
ls  k8s/lift-and-shift/
```

Take a look at the blue deployment manifest as an example of the files you just created.
```editor:select-matching-text
file: ~/color-app/k8s/lift-and-shift/blue-deployment.yaml
text: "kind: Deployment" 
```

When running the apps locally, you had to ensure that each app ran on a separate port.
One benefit of running containers in Kubernetes is that you no longer need to manage port conflicts. 
This means all apps can start on the same port, which makes for simpler configuration.

Edit the deployment manifests to set the Spring Boot `server.port` property to 8080 using an environment variable.
This will override the `server.port` value set in the `application.properties` files.

You can use `yq`, a command-line tool for transforming yaml, to add an environment variable to each deployment manifest.
```execute-1
for i in k8s/lift-and-shift/*-deployment.yaml; do \
    yq eval \
        '.spec.template.spec.containers[0].env[0].key = "SERVER_PORT"' \
        -i $i; \
    yq eval \
        '.spec.template.spec.containers[0].env[0].value = "8080"' \
        -i $i; \
done
```

Return to the blue deployment manifest to verify that the environment variable has been added.
```editor:select-matching-text
file: ~/color-app/k8s/lift-and-shift/blue-deployment.yaml
text: "env:" 
```

## Create service manifests

Use the same "dry-run" approach as above to create the service manifests without applying them to Kubernetes.
In this step, you take advantage of the fact that all containers will be listening on port 8080 to make the service manifest configuration simpler as well.
```execute-1
kubectl create service clusterip configserver \
            --tcp 80:8080 \
            -o yaml --dry-run=client > k8s/lift-and-shift/configserver-service.yaml

kubectl create service clusterip eurekaserver \
            --tcp 80:8080 \
            -o yaml --dry-run=client > k8s/lift-and-shift/eurekaserver-service.yaml

kubectl create service clusterip blue \
            --tcp 80:8080 \
            -o yaml --dry-run=client > k8s/lift-and-shift/blue-service.yaml

kubectl create service clusterip green \
            --tcp 80:8080 \
            -o yaml --dry-run=client > k8s/lift-and-shift/green-service.yaml

kubectl create service clusterip slowgreen \
            --tcp 80:8080 \
            -o yaml --dry-run=client > k8s/lift-and-shift/slowgreen-service.yaml

kubectl create service clusterip yellow \
            --tcp 80:8080 \
            -o yaml --dry-run=client > k8s/lift-and-shift/yellow-service.yaml

kubectl create service clusterip frontend \
            --tcp 80:8080 \
            -o yaml --dry-run=client > k8s/lift-and-shift/frontend-service.yaml

kubectl create service clusterip gateway \
            --tcp 80:8080 \
            -o yaml --dry-run=client > k8s/lift-and-shift/gateway-service.yaml

kubectl create service clusterip authgateway \
            --tcp 80:8080 \
            -o yaml --dry-run=client > k8s/lift-and-shift/authgateway-service.yaml
```

List all of the files you just created.
```execute-1
ls  k8s/lift-and-shift/ | grep service
```

Take a look at the blue service manifest as an example of the files you just created.
```editor:select-matching-text
file: ~/color-app/k8s/lift-and-shift/blue-service.yaml
text: "kind: Deployment" 
```
