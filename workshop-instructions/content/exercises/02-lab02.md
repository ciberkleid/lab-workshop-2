# Run locally

## Start the apps using `mvn spring-boot:run`
Run the application in the workshop terminal to see the application in action.

First, start Eureka in the background and save the process id so that you can easily stop the application at the end of this exercise.
```execute-1
cd eureka
nohup ./mvnw spring-boot:run > eureka-logs.txt 2>&1 </dev/null &
EUREKA_PID="$!"
cd ..
```

Check status of your Eureka server:
```execute-2
tail ~/color-app/eureka/eureka-logs.txt -f
```

When you see output similar to the following in the logs, it means that Eureka is up and running.
```
2021-04-15 13:06:09.208  INFO 743 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8761 (http) with context path ''
2021-04-15 13:06:09.210  INFO 743 --- [           main] .s.c.n.e.s.EurekaAutoServiceRegistration : Updating port to 8761
2021-04-15 13:06:09.227  INFO 743 --- [       Thread-8] e.s.EurekaServerInitializerConfiguration : Started Eureka Server
2021-04-15 13:06:09.240  INFO 743 --- [           main] com.example.eureka.EurekaApplication     : Started EurekaApplication in 7.404 seconds (JVM running for 8.25)
2021-04-15 13:07:09.197  INFO 743 --- [a-EvictionTimer] c.n.e.registry.AbstractInstanceRegistry  : Running the evict task with compensationTime 0ms
```

Exit the tailing of the log.
```terminal:interrupt
session: 2
```

You can send a request to Eureka to see any apps that have registered themselves (currently none):
```execute-1
curl http://localhost:8761/eureka/apps 
```

You should see a response like:
```
<applications>
  <versions__delta>1</versions__delta>
  <apps__hashcode></apps__hashcode>
</applications>
```

Next, start a Color Application instance using the `blue` profile.
```execute-1
cd blueorgreenservice
nohup ./mvnw spring-boot:run -Dspring.profiles.active=blue > blue-logs.txt 2>&1 </dev/null &
BLUE_PID="$!"
cd ..
```

Check status of your `blue` Color Application:
```execute-2
tail ~/color-app/blueorgreenservice/blue-logs.txt -f
```

When you see output similar to the following in the logs, it means that the `blue` app is up and running.
```
2021-04-15 13:15:53.858  INFO 1119 --- [nfoReplicator-0] com.netflix.discovery.DiscoveryClient    : DiscoveryClient_BLUEORGREEN/my-workshop-w01-s001-785dfb6678-l88lq:blueorgreen:8181: registering service...
2021-04-15 13:15:54.026  INFO 1119 --- [           main] s.b.c.e.t.TomcatEmbeddedServletContainer : Tomcat started on port(s): 8181 (http)
2021-04-15 13:15:54.028  INFO 1119 --- [           main] .s.c.n.e.s.EurekaAutoServiceRegistration : Updating port to 8181
2021-04-15 13:15:54.033  INFO 1119 --- [           main] o.s.demo.BlueOrGreenApplication          : Started BlueOrGreenApplication in 10.067 seconds (JVM running for 213.126)
2021-04-15 13:15:54.745  INFO 1119 --- [nfoReplicator-0] com.netflix.discovery.DiscoveryClient    : DiscoveryClient_BLUEORGREEN/my-workshop-w01-s001-785dfb6678-l88lq:blueorgreen:8181 - registration status: 204
```

Exit the tailing of the log.
```terminal:interrupt
session: 2
```

Validate that the `blue` app is running. 
Per the profile configuration, the `blue` app uses port 8181.
```execute-1
curl http://localhost:8181
```

Your output will look like this.
```
{"id":"blue"}
```

Validate that the `blue` app has registered itself with Eureka. 
It uses the application name `BLUEORGREEN`.
```dashboard:open-dashboard
name: Eureka
```

Start three more Color App instances: a green, a slow green that injects a delay of 5 seconds, and a yellow. 
The profiles are configured such that each will run on a different port.
```execute-1
cd blueorgreenservice
nohup ./mvnw spring-boot:run -Dspring.profiles.active=green > blue-green.txt 2>&1 </dev/null &
GREEN_PID="$!"

nohup ./mvnw spring-boot:run -Dspring.profiles.active=slowgreen > blue-slowgreen.txt 2>&1 </dev/null &
SLOWGREEN_PID="$!"

nohup ./mvnw spring-boot:run -Dspring.profiles.active=yellow > blue-yellow.txt 2>&1 </dev/null &
YELLOW_PID="$!"

cd ..
```

Validate that all four color app instances have registered themselves with Eureka. 
They all use the same application name, `BLUEORGREEN`, and each adds an endpoint with a unique port number.
```dashboard:open-dashboard
name: Eureka
```

When the `yellow` app registers itself in Eureka, it includes additional metadata indicating that it is a premium service.
```editor:select-matching-text
file: ~/color-app/blueorgreenservice/src/main/resources/application-yellow.yml
text: "type: premium" 
```
 
You can also validate that this metadata has been in fact registered in Eureka. 
The endpoint curled below returns details on all instances. 
Notice, however, that only the instance running on port 8282 (`yellow`) contains this extra piece of metadata. 
Keep this in mind and we will see how it is used for routing.
```execute-1
curl http://localhost:8761/eureka/apps | grep -B 3 -A 1 "premium"
```

Your output will look like this.
```
      <metadata>
        <instanceId>blueorgreen:8282</instanceId>
        <management.port>8282</management.port>
        <type>premium</type>
      </metadata>
```

Next, you will start the frontend application. 
Before doing so, however, you need to update a property so that the authorization works properly in a local environment.
```execute-1
sed -i s/#removeTypeCookie/removeTypeCookie/ ~/color-app/blueorgreenfrontend/src/main/resources/application.yml
```

Now, start the frontend application.
```execute-1
cd blueorgreenfrontend
nohup ./mvnw spring-boot:run > frontend-logs.txt 2>&1 </dev/null &
FRONTEND_PID="$!"
cd ..
```

Start the routing gateway application.
```execute-1
cd blueorgreengateway
nohup ./mvnw spring-boot:run > gateway-logs.txt 2>&1 </dev/null &
GW_PID="$!"
cd ..
```

Start the auth gateway application.
```execute-1
cd authgateway
nohup ./mvnw spring-boot:run > authgateway-logs.txt 2>&1 </dev/null &
AUTHGW_PID="$!"
cd ..
```

Check the Eureka dashboard again to validate that all apps are running. You should see four distinct application names, and four instances of apps listed under the `blueorgreen` application name.
```dashboard:open-dashboard
name: Eureka
```

## Test the app

Since this is a local deployment, any of the apps is reachable at its host:port address. 
However, the intention of the design is that, in a production environment, only the auth gateway would be routable, and the rest of the apps would be protected behind the auth gateway in an internal network.

Test the app by opening the Auth Gateway endpoint in the browser.
```dashboard:open-dashboard
name: AuthGateway
```

Notice that you are automatically routed to a login page. 
Log in using username `user` and password `pw`. 
(These credentials are hard-coded in the Auth Gateway for simplicity).

After logging in, refresh the page several times. 
You should see the color rotate between blue, green, and the slow green, which takes 5 seconds to load.

In the browser, add `/logout` to the end of the URL and hit `Enter`. 
This will log you out of the application. 
Log in again using username `premium` and password `pw`. 
Refresh the page several times. 
You should now see yellow amongst the colors.

## Add a fallback for the slow green and re-test

The color application currently waits indefinitely for the slow green to return. 
Update the Routing Gateway code so that any call to a color service times out after 1 second and returns red as a fallback.

First, find the line that needs to be edited in the code.
```editor:select-matching-text
file: ~/color-app/blueorgreengateway/src/main/java/org/springframework/demo/blueorgreengateway/BlueorgreengatewayApplication.java
text: .route(p -> p.path("/blueorgreen").uri("lb://blueorgreen"))
```
This line routes all requests with path matching `/blueorgreen` to one of the instances registered under the handle `blueorgreen` in Eureka (aka to either blue, green, slow green, or yellow). 
These requests are made by the Javascript in the frontend app when you refresh the application in the browser.

Delete the highlighted line and replace it with the following (copy & paste).
```copy
.route(p -> p.path("/blueorgreen").filters(f -> f.hystrix(c -> c.setName("cmd").setFallbackUri("forward:/colorfallback"))).uri("lb://blueorgreen"))
```

The resulting `routeLocator` method should look like this. 
You can also check this file the IDE and scroll to the end of the class file to see the fallback method, which returns red.

```
	@Bean
	public RouteLocator routeLocator(RouteLocatorBuilder builder) {
		return builder.routes()
				.route(p -> p.path("/blueorgreen").filters(f -> f.hystrix(c -> c.setName("cmd").setFallbackUri("forward:/colorfallback"))).uri("lb://blueorgreen"))
				.route(p -> p.path("/").or().path("/color").or().path("/js/**").uri("lb://blueorgreenfrontend"))
				.build();
	}
```

Restart the Routing Gateway application.
```execute-1
# Stop the routing gateway
kill $GW_PID && wait $!

# Start the routing gateway
cd blueorgreengateway
nohup ./mvnw spring-boot:run > gateway-logs.txt 2>&1 </dev/null &

GW_PID="$!"
cd ..
```
 
 Test the app again, using either `user` or `premium` to log in. 
You should see that `red` appears after a single second delay every time slow green would otherwise be called.
 
 ## Stop the applications
 
 Stop all the locally running applications.
 ```execute-1
kill $EUREKA_PID
kill $BLUE_PID
kill $GREEN_PID
kill $SLOWGREEN_PID
kill $YELLOW_PID
kill $FRONTEND_PID
kill $GW_PID
kill $AUTHGW_PID
```
 
 ## Takeaways
 In this exercise, you deployed and tested the Color Application, comprising 5 Spring Boot applications, locally. 
You should now have a good understanding of how the app works and the expected behavior.
 
 ## Next steps
 
 Your company, Colorific Corporation, needs to reduce operational burden of running and managing the color application at scale. 
They have decided to move all apps to Kubernetes. 
In the next sections, we will explore a couple of approaches for moving the Color Application to Kubernetes and discuss the benefits of each.
 
