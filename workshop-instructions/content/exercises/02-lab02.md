# Run locally

## Start the apps using `mvn spring-boot:run`
Run the application in the workshop terminal to see the application in action.

First, start Eureka in the background and save the process id so that you can easily stop the application at the end of this exercise.
```execute-1
clear
cd eureka
nohup ./mvnw spring-boot:run > eureka-logs.txt 2>&1 </dev/null &
EUREKA_PID="$!"
cd ..
```

Check status of your Eureka server:
```execute-2
tail ~/color-app/eureka/eureka-logs.txt -f
```

When you see output similar to the following in the logs, it means that Eureka is up and running.
```
2021-04-15 13:06:09.208  INFO 743 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8761 (http) with context path ''
2021-04-15 13:06:09.210  INFO 743 --- [           main] .s.c.n.e.s.EurekaAutoServiceRegistration : Updating port to 8761
2021-04-15 13:06:09.227  INFO 743 --- [       Thread-8] e.s.EurekaServerInitializerConfiguration : Started Eureka Server
2021-04-15 13:06:09.240  INFO 743 --- [           main] com.example.eureka.EurekaApplication     : Started EurekaApplication in 7.404 seconds (JVM running for 8.25)
```

Once Eureka has started, you can access its dashboard:
> Note: 
> If you accidentally click `localhost` you can right click` and select 'back' to return to previous page.

```dashboard:open-dashboard
name: Eureka
```

Exit the tailing of the log.
```terminal:interrupt
session: 2
```

Next, start a Color Application instance using the `blue` profile.
```execute-1
cd blueorgreenservice
nohup ./mvnw spring-boot:run -Dspring-boot.run.profiles=blue > blue-logs.txt 2>&1 </dev/null &
BLUE_PID="$!"
cd ..
```

Check status of your `blue` Color Application:
```execute-2
tail ~/color-app/blueorgreenservice/blue-logs.txt -f
```

When you see output similar to the following in the logs, it means that the `blue` app is up and running.
```
2021-04-15 13:15:54.026  INFO 1119 --- [           main] s.b.c.e.t.TomcatEmbeddedServletContainer : Tomcat started on port(s): 8181 (http)
2021-04-15 13:15:54.028  INFO 1119 --- [           main] .s.c.n.e.s.EurekaAutoServiceRegistration : Updating port to 8181
2021-04-15 13:15:54.033  INFO 1119 --- [           main] o.s.demo.BlueOrGreenApplication          : Started BlueOrGreenApplication in 10.067 seconds (JVM running for 213.126)
2021-04-15 13:15:54.745  INFO 1119 --- [nfoReplicator-0] com.netflix.discovery.DiscoveryClient    : DiscoveryClient_BLUEORGREEN/my-workshop-w01-s001-785dfb6678-l88lq:blueorgreen:8181 - registration status: 204
```

Exit the tailing of the log.
```terminal:interrupt
session: 2
```

Validate that the `blue` app is running. 
Per the profile configuration, the `blue` app uses port 8181.
```execute-1
http -p b :8181
```

Your output will look like this.
```
{
    "id": "blue"
}
```

Validate that the `blue` app has registered itself with Eureka. 
It uses the application name `BLUEORGREEN`.
```dashboard:reload-dashboard
name: Eureka
```

Start three more Color App instances: a green, a slow green that injects a delay of 5 seconds, and a yellow. 
The profiles are configured such that each will run on a different port.
```execute-1
cd blueorgreenservice

nohup ./mvnw spring-boot:run -Dspring-boot.run.profiles=green > green-logs.txt 2>&1 </dev/null &
GREEN_PID="$!"

nohup ./mvnw spring-boot:run -Dspring-boot.run.profiles=slowgreen > slowgreen-logs.txt 2>&1 </dev/null &
SLOWGREEN_PID="$!"

nohup ./mvnw spring-boot:run -Dspring-boot.run.profiles=yellow > yellow-logs.txt 2>&1 </dev/null &
YELLOW_PID="$!"

cd ..
```

Validate that all four color app instances have registered themselves with Eureka. 
You may need to execute the following command several times (each time you click it will reload the Eureka dashboard).
All four instances use the same application name, `BLUEORGREEN`, and each instance adds an endpoint to the `Status` column with a unique port number.
```dashboard:reload-dashboard
name: Eureka
```

The `yellow` instance is a bit different from the other color instances. 
When `yellow` registers itself in Eureka, it includes additional metadata indicating that it is a premium service.
```editor:select-matching-text
file: ~/color-app/blueorgreenservice/src/main/resources/application-yellow.yml
text: "type: premium" 
```
 
You can also validate that this metadata has in fact been registered in Eureka. 
The command below retrieves details on all instances, and then filters the results using the key word `premium`. 
Notice that only the instance running on port 8282 (`yellow`) contains metadata containing this key word. 
Keep this in mind and we will see how it is used for routing.
```execute-1
http -p b :8761/eureka/apps | grep -B 3 -A 1 "premium"
```

Your output will look like this.
```
      <metadata>
        <instanceId>blueorgreen:8282</instanceId>
        <management.port>8282</management.port>
        <type>premium</type>
      </metadata>
```

Next, start the frontend application.
For this app, we are including a command to uncomment a particular property needed for local testing.
```execute-1
cd blueorgreenfrontend
# Uncomment removeTyperCookie property
sed -i s/#removeTypeCookie/removeTypeCookie/ src/main/resources/application.yml
nohup ./mvnw spring-boot:run > frontend-logs.txt 2>&1 </dev/null &
FRONTEND_PID="$!"
cd ..
```

Start the routing gateway application.
```execute-1
cd blueorgreengateway
nohup ./mvnw spring-boot:run > gateway-logs.txt 2>&1 </dev/null &
GW_PID="$!"
cd ..
```

Start the auth gateway application.
```execute-1
cd authgateway
nohup ./mvnw spring-boot:run > authgateway-logs.txt 2>&1 </dev/null &
AUTHGW_PID="$!"
cd ..
```

Check the Eureka dashboard again to validate that all apps are running. You should see four distinct application names, and four instances of apps listed under the `blueorgreen` application name. The apps may take a minute or so to start up. Refresh the dashboard until you see all of them registered.
```dashboard:reload-dashboard
name: Eureka
```

## Test the app

Since this is a local deployment, any of the apps is reachable at its host:port address. 
However, the intention of the design is that, in a production environment, only the auth gateway would be routable, and the rest of the apps would be protected behind the auth gateway in an internal network.

Test the app by opening the Auth Gateway endpoint in the browser.
```dashboard:open-dashboard
name: AuthGateway
```

Notice that you are automatically routed to a login page. 

- Log in using username `user` and password `pw`. 
(These credentials are hard-coded in the Auth Gateway for simplicity).

- After logging in, refresh the page several times by clicking repeatedly on the following instruction.
 ```dashboard:reload-dashboard
 name: AuthGateway
 ```

As you reload the page, you should see the color rotate between blue, green, and the slow green, which takes 5 seconds to load.

Log out of the application:
 ```dashboard:open-dashboard
 name: AuthGatewayLogout
 ```

Then, log in again using username `premium` and password `pw`. 
 ```dashboard:reload-dashboard
 name: AuthGateway
 ```

Refresh the page several times. 
You should now see yellow amongst the colors.
 ```dashboard:reload-dashboard
 name: AuthGateway
 ```

## Add a fallback for the slow green and re-test

The color application currently waits indefinitely for the slow green to return. 
Update the Routing Gateway code so that any call to a color service times out after 1 second and returns red as a fallback.

First, find the line that needs to be edited in the code.
```editor:select-matching-text
file: ~/color-app/blueorgreengateway/src/main/java/org/springframework/demo/blueorgreengateway/BlueorgreengatewayApplication.java
text: .route(p -> p.path("/blueorgreen").uri("lb://blueorgreen"))
```
This line routes all requests with path matching `/blueorgreen` to one of the instances registered under the handle `blueorgreen` in Eureka (aka to either blue, green, slow green, or yellow). 
These requests are made by the Javascript in the frontend app when you refresh the application in the browser.

Delete the highlighted line and replace it with the following (copy & paste).
```copy
.route(p -> p.path("/blueorgreen").filters(f -> f.hystrix(c -> c.setName("cmd").setFallbackUri("forward:/colorfallback"))).uri("lb://blueorgreen"))
```

The resulting `routeLocator` method should look like this. 
You can also check this file the IDE and scroll to the end of the class file to see the fallback method, which returns red.

```
	@Bean
	public RouteLocator routeLocator(RouteLocatorBuilder builder) {
		return builder.routes()
				.route(p -> p.path("/blueorgreen").filters(f -> f.hystrix(c -> c.setName("cmd").setFallbackUri("forward:/colorfallback"))).uri("lb://blueorgreen"))
				.route(p -> p.path("/").or().path("/color").or().path("/js/**").uri("lb://blueorgreenfrontend"))
				.build();
	}
```

Restart the Routing Gateway application.
```execute-1
# Stop the routing gateway
kill $GW_PID && wait $!

# Start the routing gateway
cd blueorgreengateway
nohup ./mvnw spring-boot:run > gateway-logs.txt 2>&1 </dev/null &

GW_PID="$!"
cd ..
```
 
 Test the app again, using either `user` or `premium` to log in. 
You should see that `red` appears after a single second delay every time slow green would otherwise be called.
Refresh the page several times. 
You should now see yellow amongst the colors.
 ```dashboard:reload-dashboard
 name: AuthGateway
 ```
 
 ## Stop the applications
 
 Stop all the locally running applications.
 ```execute-1
kill $EUREKA_PID
kill $BLUE_PID
kill $GREEN_PID
kill $SLOWGREEN_PID
kill $YELLOW_PID
kill $FRONTEND_PID
kill $GW_PID
kill $AUTHGW_PID
```

If you need to exit the command:
```terminal:interrupt
session: 1
```
 
 ## Takeaways
 In this exercise, you deployed and tested the Color Application, comprising 5 Spring Boot applications, locally. 
You should now have a good understanding of how the app works and the expected behavior.
 
 ## Next steps
 
 Your company, Colorific Corporation, needs to reduce operational burden of running and managing the color application at scale. 
They have decided to move all apps to Kubernetes. 
In the next sections, we will explore a couple of approaches for moving the Color Application to Kubernetes and discuss the benefits of each.
 
