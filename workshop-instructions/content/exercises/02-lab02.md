# Run locally

## Start the apps using `mvn spring-boot:run`
Run the application in the workshop terminal to see the application in action.

First, start the Config Server and the Eureka Server.
> Note: The following startup commands will run the Java processes in the background, so you won't see the app startup log appear in the terminal window.
> Instead, any logging will be redirected to a file.
```execute-1
cd configserver
nohup ./mvnw spring-boot:run > log.out 2>&1 </dev/null &
cd ../eurekaserver
nohup ./mvnw spring-boot:run > log.out 2>&1 </dev/null &
cd ..
```

Check the status of your Config Server.
```execute-2
tail ~/color-app/configserver/log.out -f
```

When you see output similar to the following in the logs, it means that Config Server is up and running.
```
2021-04-20 21:57:03.216  INFO 658 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8888 (http) with context path ''
2021-04-20 21:57:03.239  INFO 658 --- [           main] c.e.c.ConfigserverApplication            : Started ConfigserverApplication in 3.598 seconds (JVM running for 4.122)
```

Alternatively, you can run the following command repeatedly until you see the expected output to confirm the Config Server has started:
```execute-1
cat ~/color-app/configserver/log.out | grep "started on port"
```

Exit the tailing of the log.
```terminal:interrupt
session: 2
```

Check the status of your Eureka Server:
```execute-2
tail ~/color-app/eurekaserver/log.out -f
```

When you see output similar to the following in the logs, it means that Eureka Server is up and running.
```
2021-04-20 21:57:27.152  INFO 716 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8761 (http) with context path ''
2021-04-20 21:57:27.153  INFO 716 --- [           main] .s.c.n.e.s.EurekaAutoServiceRegistration : Updating port to 8761
2021-04-20 21:57:27.159  INFO 716 --- [       Thread-8] e.s.EurekaServerInitializerConfiguration : Started Eureka Server
2021-04-20 21:57:27.180  INFO 716 --- [           main] c.e.e.EurekaserverApplication            : Started EurekaserverApplication in 4.883 seconds (JVM running for 5.4)
```

Alternatively, you can run the following command repeatedly until you see the expected output to confirm the Config Server has started:
```execute-1
cat ~/color-app/eurekaserver/log.out | grep "started on port"
```

Exit the tailing of the log.
```terminal:interrupt
session: 2
```

Once Eureka has started, you can access its dashboard:
> Note: 
> If you accidentally click `localhost` you can right click and select 'back' to return to previous page.

```dashboard:open-dashboard
name: Eureka
```

Next, start a Color Application instance using the `blue` profile.
```execute-1
cd blueorgreenservice
nohup ./mvnw spring-boot:run -Dspring-boot.run.profiles=blue > log-blue.out 2>&1 </dev/null &
cd ..
```

Check the status of your `blue` Color Application:
```execute-2
tail ~/color-app/blueorgreenservice/log-blue.out -f
```

When you see output similar to the following in the logs, it means that the `blue` app is up and running.
```
2021-04-20 21:58:43.563  INFO 798 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8181 (http) with context path ''
2021-04-20 21:58:43.564  INFO 798 --- [           main] .s.c.n.e.s.EurekaAutoServiceRegistration : Updating port to 8181
2021-04-20 21:58:43.583  INFO 798 --- [           main] o.s.demo.BlueOrGreenApplication          : Started BlueOrGreenApplication in 9.204 seconds (JVM running for 9.721)
```

Exit the tailing of the log.
```terminal:interrupt
session: 2
```

Validate that the `blue` app is running. 
Per the profile configuration, the `blue` app uses port 8181.
```execute-1
http -p b :8181
```

Your output will look like this.
```
{
    "id": "blue"
}
```

Validate that the `blue` app has registered itself with Eureka. 
It uses the application name `BLUEORGREEN`.
```dashboard:reload-dashboard
name: Eureka
```

In order to retrieve its configuration, the app connected to the Config Server and pulled any general configuration (from `config-files/application.yml`), as well as app-specific configuration based on a match with the app's `spring.application.name` value (from `config-files/blueorgreen.yml`), and app/profile-specific configuration, based on the `blue` profile declared in the startup command (from `config-files/blueorgreen-blue.yml`).

You can see the configuration files here:
```
```editor:open-file
file: ~/color-app/config-files/blueorgreen-blue.yml
```

You can also query the Config Server to see the combined settings it provides for a blueorgreen instance with profile blue:
```
http :8888/blueorgreen/blue
```

Start two more Color App instances: green an yellow. 
The profiles are configured such that each will run on a different port.
```execute-1
cd blueorgreenservice
nohup ./mvnw spring-boot:run -Dspring-boot.run.profiles=green > log-green.out 2>&1 </dev/null &
nohup ./mvnw spring-boot:run -Dspring-boot.run.profiles=yellow > log-yellow.out 2>&1 </dev/null &
cd ..
```

Validate that all three color app instances have registered themselves with Eureka. 
All three instances use the same application name, `BLUEORGREEN`, and each instance adds an endpoint to the `Status` column with a unique port number.
> Note: You may need to execute the following command several times (each time you click it will reload the Eureka dashboard).
```dashboard:reload-dashboard
name: Eureka
```

The `yellow` instance is a bit different from the other color instances. 
When `yellow` registers itself in Eureka, it includes additional metadata indicating that it is a premium service.
You can verify that this metadata is registered in Eureka using the following command, which retrieves details on all instances, and then filters the results using the key word `premium`. 
Notice that only the instance running on port 8282 (`yellow`) contains metadata containing the `premium` key word. 
Keep this in mind and we will see how it is used for routing.
```execute-1
http -p b :8761/eureka/apps | grep -B 3 -A 1 "<type>premium</type>"
```

Your output will look like this.
```
      <metadata>
        <instanceId>blueorgreen:8282</instanceId>
        <management.port>8282</management.port>
        <type>premium</type>
      </metadata>
```

Next, start the frontend application.
```execute-1
cd blueorgreenfrontend
nohup ./mvnw spring-boot:run -Dspring-boot.run.profiles=local > log.out 2>&1 </dev/null &
cd ..
```

Start the routing gateway application.
```execute-1
cd blueorgreengateway
nohup ./mvnw spring-boot:run > log.out 2>&1 </dev/null &
cd ..
```

Start the auth gateway application.
```execute-1
cd authgateway
nohup ./mvnw spring-boot:run > log.out 2>&1 </dev/null &
cd ..
```

Check the Eureka dashboard again to validate that all apps are running. You should see four distinct application names in `APPLICATION` column.
For the `BLUEORGREEN` application, you should see three distinct endpoints under the `Status` column.
The apps may take a minute or so to start up. 
Refresh the dashboard until you see all of them registered.
```dashboard:reload-dashboard
name: Eureka
```

## Test the app

Since this is a local deployment, any of the apps is reachable at its `host:port` address. 
However, the intention of the design is that, in a production environment, only the Auth Gateway would be externally routable, and the rest of the apps would be protected behind the Auth Gateway in an internal network.

The Auth Gateway applies a security filter, redirecting the user to a login page if the user has not yet been authenticated. 
After that, it forwards requests to the Routing Gateway, which in turn routes requests to the remaining applications. 

The Config Server app retrieves all configuration files from the [`config-files` directory on GitHub](https://github.com/springone-tour-2021/gateway-s1p-2018/tree/master/config-files).
 Each app communicates with the Config Server during startup to obtain its respective configuration.
 You can see the configuration for the config source here:
 ```editor:select-matching-text
 file: ~/color-app/configserver/src/main/resources/application.properties
 text: "spring.cloud.config.server.git.uri"
 before: 0
 after: 1
 ```

In addition to this, every app that needs to forward a request to another app uses Eureka to look up the endpoint of the destination app.

Test the app by opening the Auth Gateway endpoint in the browser.
```dashboard:open-dashboard
name: AuthGateway
```

Notice that you are automatically routed to a login page. 

- Log in using username `user` and password `pw`. 
(These credentials are hard-coded in the Auth Gateway for simplicity; in a production scenario, the Auth Gateway would be integrated with an Identity Management system).

- After logging in, refresh the page several times by clicking repeatedly on the following instruction.
 ```dashboard:reload-dashboard
 name: AuthGateway
 ```

As you reload the page, you should see the color rotate between blue and green. You should **not** see yellow.

Log out of the application:
 ```dashboard:open-dashboard
 name: AuthGatewayLogout
 ```

Then, log in again using username `premium` and password `pw`. 
 ```dashboard:reload-dashboard
 name: AuthGateway
 ```

Refresh the page several times. 
You should now see blue, green, and yellow.
 ```dashboard:reload-dashboard
 name: AuthGateway
 ```

## Test the circuit breaker and fallback configuration

The routing gateway will currently wait up to one second for a color service instance to return. If it does not receive a response, it resorts to a fallback action, which returns a hard-coded value of "red".

Take a look at the code that defines this behavior.
```editor:select-matching-text
file: ~/color-app/blueorgreengateway/src/main/java/org/springframework/demo/blueorgreengateway/BlueorgreengatewayApplication.java
text: .filters(f -> f.circuitBreaker(c -> c.setFallbackUri("forward:/colorfallback")))
```

The circuit breaker imposes a default timeout, and the `colorfallback` method (defined lower down in the same .java file) returns `red` as the fallback value.

Start a new `slowgreen` instance and restart the Routing Gateway application.
```execute-1
cd blueorgreenservice
nohup ./mvnw spring-boot:run -Dspring-boot.run.profiles=slowgreen > log-slowgreen.out 2>&1 </dev/null &
cd ..

# Stop and restart the routing gateway
http :8383/actuator/shutdown

cd blueorgreengateway
nohup ./mvnw spring-boot:run > log.out 2>&1 </dev/null &
cd ..
```

Test the `slowgreen` instance individually to verify that it takes 5 seconds to return.
```execute-1
http :6060
```
 
Now, test the Color Application using the AuthGateway dashboard, using either `user` or `premium` to log in. 
You should see that `red` appears after a single second delay every time slow green would otherwise be called.

Refresh the page several times. 
You should now see yellow amongst the colors.

 ```dashboard:reload-dashboard
 name: AuthGateway
 ```
 
 ## Stop the applications
 
 Stop all the locally running applications.
 ```execute-1
http POST :8080/actuator/shutdown
http POST :8383/actuator/shutdown
http POST :9090/actuator/shutdown
http POST :8181/actuator/shutdown
http POST :7070/actuator/shutdown
http POST :8282/actuator/shutdown
http POST :6060/actuator/shutdown
http POST :8761/actuator/shutdown
http POST :8888/actuator/shutdown
```

If you need to exit the command:
```terminal:interrupt
session: 1
```
 
 ## Takeaways
 In this exercise, you deployed and tested the Color Application locally at your terminal. The Color Application comprises 6 Spring Boot applications, including the Config and Eureka Servers. 
You should now have a good understanding of how the app works and the expected behavior.
 
 ## Next steps
 
 Your company, Colorific Corporation, needs to reduce operational burden of running and managing the color application at scale. 
They have decided to move all apps to Kubernetes. 
In the next sections, we will explore a couple of approaches for moving the Color Application to Kubernetes and discuss the benefits and challenges.
 
