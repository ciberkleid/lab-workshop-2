# Run locally

## Start the apps using `mvn spring-boot:run`
Run the application in the workshop terminal to see the application in action.

First, start Eureka in the background and save the process id so that you can easily stop the application at the end of this exercise.
```execute-1
cd eureka-server
nohup ./mvnw spring-boot:run 2>&1 > eureka-logs.txt & 
EUREKA_PID="$!"
cd ..
```

Check status of your Eureka sserver:
```execute-2
cat  ~/color-app/eureka-server/eureka-logs.txt
```

You can exit this command and `nohup` will keep your Eureka server running in the background
```terminal:interrupt
session: 1
```

To check it's running:
```execute-2
curl http://localhost:8761/eureka/apps 
```

You should see a response like:
```
<applications>
<versions__delta>1</versions__delta>
<apps__hashcode></apps__hashcode>
```

Next, start a Color Application instance using the `blue` profile.
```execute-1
cd blueorgreenservice
nohup ./mvnw spring-boot:run -Dspring.profiles.active=blue 2>&1 > blue-logs.txt &
BLUE_PID="$!"
cd ..
```

As aforementioned exit and `nohup` will keep your `blue` app running in the background.
```terminal:interrupt
session: 1
```

Validate that the `blue` app is running. 
Per the profile configuration, the blue app uses port 8181.
```execute-1
curl http://localhost:8181
```

Your output will look like this.
```
{"id":"blue"}
```

Validate that the `blue` app has registered itself with Eureka. 
It uses the application name `BLUEORGREEN`.
```dashboard:open-dashboard
name: Eureka
```

Start three more Color App instances: a green, a slow green that injects a delay of 5 seconds, and a yellow. 
The profiles are configured such that each will run on a different port.
```execute-1
cd blueorgreenservice
nohup ./mvnw spring-boot:run -Dspring.profiles.active=green 2>&1 > green-logs.txt &
GREEN_PID="$!"

nohup ./mvnw spring-boot:run -Dspring.profiles.active=slowgreen 2>&1 > slowgreen-logs.txt &
SLOWGREEN_PID="$!"

nohup ./mvnw spring-boot:run -Dspring.profiles.active=yellow 2>&1 > yellow-logs.txt &
YELLOW_PID="$!"

cd ..
```

Validate that all four color app instances have registered themselves with Eureka. 
They all use the same application name, `BLUEORGREEN`, and each adds an endpoint with a unique port number.
```dashboard:open-dashboard
name: Eureka
```

The `yellow` app profile includes additional metadata to register with Eureka indicating that this app should only be available to premium users.
```editor:select-matching-text
file: ~/color-app/blueorgreenservice/src/main/resources/application-yellow.yml
text: "type: premium" 
```
 
You can also validate that this metadata has been in fact registered in Eureka. 
The endpoint curled below returns details on all instances. 
Notice, however, that only the instance running on port 8282 (`yellow`) contains this extra piece of metadata. 
Keep this in mind and we will see how it is used for routing.
```execute-1
curl http://localhost:8761/eureka/apps | grep -B 3 -A 1 "premium"
```

Next, you will start the frontend application. 
Before doing so, however, you need to update a property so that the authorization works properly in a local environment.
```execute-1
sed -i s/#removeTypeCookie/removeTypeCookie/ blueorgreenfrontend/src/main/resources/application.yml
```

Now, start the frontend application.
```execute-1
cd blueorgreenfrontend
nohup ./mvnw spring-boot:run &
FRONTEND_PID="$!"
cd ..
```

Start the routing gateway application.
```execute-1
cd blueorgreengateway
nohup ./mvnw spring-boot:run &
GW_PID="$!"
cd ..
```

Start the auth gateway application.
```execute-1
cd authgateway
nohup ./mvnw spring-boot:run &
AUTHGW_PID="$!"
cd ..
```

Check the Eureka dashboard again to validate that all four apps are registered, and that all four instances of the `blueorgreen` app are registered.
```dashboard:open-dashboard
name: Eureka
```

## Test the app

Since this is a local deployment, any of the apps is reachable at its host:port address. 
However, the intention of the design is that, in a production environment, only the auth gateway would be routable, and the rest of the apps would be protected behind the auth gateway in an internal network.

Test the app by opening the Auth Gateway endpoint in the browser.
```dashboard:open-dashboard
name: AuthGateway
```

Notice that you are automatically routed to a login page. 
Log in using username `user` and password `pw`. 
(These credentials are hard-coded in the Auth Gateway for simplicity).

After logging in, refresh the page several times. 
You should see the color rotate between blue, green, and the slow green, which takes 5 seconds to load.

In the browser, add `/logout` to the end of the URL and hit `Enter`. 
This will log you out of the application. 
Log in again using username `premium` and password `pw`. 
Refresh the page several times. 
You should now see yellow amongst the colors.

## Add a fallback for the slow green and re-test

The color application currently waits indefinitely for the slow green to return. 
Update the Routing Gateway code so that any call to a color service times out after 1 second and returns red as a fallback.

First, find the line that needs to be edited in the code.
```editor:select-matching-text
file: ~/color-app/blueorgreengateway/src/main/java/org/springframework/demo/blueorgreengateway/BlueorgreengatewayApplication.java
text: .route(p -> p.path("/blueorgreen").uri("lb://blueorgreen"))
```
This line routes all requests with path matching `/blueorgreen` to one of the instances registered under the handle `blueorgreen` in Eureka (aka to either blue, green, slow green, or yellow). 
These requests are made by the Javascript in the frontend app when you refresh the application in the browser.

Delete the highlighted line and replace it with the following (copy & paste).
```
.route(p -> p.path("/blueorgreen").filters(f -> f.hystrix(c -> c.setName("cmd").setFallbackUri("forward:/colorfallback"))).uri("lb://blueorgreen"))
```

The resulting `routeLocator` method should look like this. 
You can also check this file the IDE and scroll to the end of the class file to see the fallback method, which returns red.

```
	@Bean
	public RouteLocator routeLocator(RouteLocatorBuilder builder) {
		return builder.routes()
				.route(p -> p.path("/blueorgreen").filters(f -> f.hystrix(c -> c.setName("cmd").setFallbackUri("forward:/colorfallback"))).uri("lb://blueorgreen"))
				.route(p -> p.path("/").or().path("/color").or().path("/js/**").uri("lb://blueorgreenfrontend"))
				.build();
	}
```

Restart the Routing Gateway application.
```execute-1
# Stop the routing gateway
kill $GW_PID && wait $!

# Start the routing gateway
cd blueorgreengateway
nohup ./mvnw spring-boot:run &
GW_PID="$!"
cd ..
```
 
 Test the app again, using either `user` or `premium` to log in. 
You should see that `red` appears after a single second delay every time slow green would otherwise be called.
 
 ## Stop the applications
 
 Stop all the locally running applications.
 ```execute-1
kill $EUREKA_PID
kill $BLUE_PID
kill $GREEN_PID
kill $SLOWGREEN_PID
kill $YELLOW_PID
kill $FRONTEND_PID
kill $GW_PID
kill $AUTHGW_PID
```
 
 ## Takeaways
 In this exercise, you deployed and tested the Color Application, comprising 5 Spring Boot applications, locally. 
You should now have a good understanding of how the app works and the expected behavior.
 
 ## Next steps
 
 Your company, Colorific Corporation, needs to reduce operational burden of running and managing the color application at scale. 
They have decided to move all apps to Kubernetes. 
In the next sections, we will explore a couple of approaches for moving the Color Application to Kubernetes and discuss the benefits of each.
 
